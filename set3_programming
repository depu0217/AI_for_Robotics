Q4
  def move(self, motion,tolerance=0.001): # Do not change the name of this function

        steering=motion[0]
        distance=motion[1]
        if abs(steering)>max_steering_angle:
            raise ValueError,'Exceeding max steering angle'
        if distance<0.0:
            raise ValueError, 'Moving backwards is not valid'
        # make a copy
        res=robot()
        res.length=self.length
        res.bearing_noise=self.bearing_noise
        res.steering_noise=self.steering_noise
        res.distance_noise=self.distance_noise
        
        # apply noise
        steering2=random.gauss(steering, self.steering_noise)
        distance2=random.gauss(distance, self.distance_noise)

        #Execute motion
        turn=tan(steering2)*distance2/res.length
        
        if abs(turn)<tolerance:
            #linear approximation
            res.x=self.x + (distance2 * cos(self.orientation))
            res.y=self.y + (distance2 * sin(self.orientation))
            res.orientation = (self.orientation + turn) % (2.0 * pi)
        else:
            # bicycle model for motion
            radius=distance2/ turn
            cx=self.x-sin(self.orientation)*radius
            cy=self.y+cos(self.orientation)*radius
            res.orientation=(self.orientation + turn) % (2.0 * pi)
            self.x = cx + sin(res.orientation)*radius
            self.y = cy - cos(res.orientation)*radius
        
        return res 

Q5
    def sense(self,add_noise=1): #do not change the name of this function
        Z = []

        # ENTER CODE HERE
        # HINT: You will probably need to use the function atan2()
        for l in range(len(landmarks)):
            bearing=atan2(landmarks[l][0]-self.y,landmarks[l][1]-self.x)-self.orientation
            if add_noise: 
                bearing = bearing + random.gauss(0.0,self.bearing_noise)
            bearing = bearing % (2.0*pi)
            Z.append(bearing)
        return Z #Leave this line here. Return vector Z of 4 bearings


